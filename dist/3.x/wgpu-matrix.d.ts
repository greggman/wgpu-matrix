/**
 * Some docs
 * @namespace wgpu-matrix
 */
import { MutableNumberArray, BaseArgType } from './types';
import { Mat3Arg, Mat3Type } from './mat3-impl';
import { Mat4Arg, Mat4Type } from './mat4-impl';
import { QuatArg, QuatType, RotationOrder } from './quat-impl';
import { Vec2Arg, Vec2Type } from './vec2-impl';
import { Vec3Arg, Vec3Type } from './vec3-impl';
import { Vec4Arg, Vec4Type } from './vec4-impl';
import * as utils from './utils';
export { RotationOrder, utils, MutableNumberArray, BaseArgType, Mat3Arg, Mat4Arg, QuatArg, Vec2Arg, Vec3Arg, Vec4Arg, Mat3Type, Mat4Type, QuatType, Vec2Type, Vec3Type, Vec4Type, };
export type BaseCtor<T extends BaseArgType> = new (n: number) => T;
export type Mat3 = Mat3Type<Float32Array>;
export type Mat4 = Mat4Type<Float32Array>;
export type Quat = QuatType<Float32Array>;
export type Vec2 = Vec2Type<Float32Array>;
export type Vec3 = Vec3Type<Float32Array>;
export type Vec4 = Vec4Type<Float32Array>;
export type Mat3d = Mat3Type<Float64Array>;
export type Mat4d = Mat4Type<Float64Array>;
export type Quatd = QuatType<Float64Array>;
export type Vec2d = Vec2Type<Float64Array>;
export type Vec3d = Vec3Type<Float64Array>;
export type Vec4d = Vec4Type<Float64Array>;
export type Mat3n = Mat3Type<number[]>;
export type Mat4n = Mat4Type<number[]>;
export type Quatn = QuatType<number[]>;
export type Vec2n = Vec2Type<number[]>;
export type Vec3n = Vec3Type<number[]>;
export type Vec4n = Vec4Type<number[]>;
export declare const 
/**
 * 3x3 Matrix functions that default to returning `Float32Array`
 * @namespace
 */
mat3: {
    add: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    clone: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    copy: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    create: (v0?: number, v1?: number, v2?: number, v3?: number, v4?: number, v5?: number, v6?: number, v7?: number, v8?: number) => Float32Array<ArrayBufferLike>;
    determinant: (m: Mat3Arg) => number;
    equals: (a: Mat3Arg, b: Mat3Arg) => boolean;
    equalsApproximately: (a: Mat3Arg, b: Mat3Arg) => boolean;
    fromMat4: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m4: Mat4Arg, dst?: T | undefined) => T;
    fromQuat: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    get3DScaling: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => Float32Array<ArrayBufferLike> | T;
    getAxis: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, axis: number, dst?: T | undefined) => T;
    getScaling: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => Float32Array<ArrayBufferLike> | T;
    getTranslation: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    identity: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    inverse: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    invert: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    mul: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    multiply: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    multiplyScalar: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    negate: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    rotate: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateX: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotation: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationX: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationY: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationZ: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    scale: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    scale3D: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec3Arg, dst?: T | undefined) => T;
    scaling: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    scaling3D: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    set: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, dst?: T | undefined) => T;
    setAxis: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec2Arg, axis: number, dst?: T | undefined) => T;
    setTranslation: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(a: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    translate: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    translation: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    transpose: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    uniformScale: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    uniformScale3D: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    uniformScaling: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(s: number, dst?: T | undefined) => T;
    uniformScaling3D: <T extends Mat3Arg = Float32Array<ArrayBufferLike>>(s: number, dst?: T | undefined) => T;
}, 
/**
 * 4x4 Matrix functions that default to returning `Float32Array`
 * @namespace
 */
mat4: {
    add: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    aim: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(position: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    axisRotate: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    axisRotation: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    cameraAim: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    clone: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    copy: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    create: (v0?: number, v1?: number, v2?: number, v3?: number, v4?: number, v5?: number, v6?: number, v7?: number, v8?: number, v9?: number, v10?: number, v11?: number, v12?: number, v13?: number, v14?: number, v15?: number) => Float32Array<ArrayBufferLike>;
    determinant: (m: Mat4Arg) => number;
    equals: (a: Mat4Arg, b: Mat4Arg) => boolean;
    equalsApproximately: (a: Mat4Arg, b: Mat4Arg) => boolean;
    fromMat3: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m3: Mat3Arg, dst?: T | undefined) => T;
    fromQuat: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    frustum: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T | undefined) => T;
    frustumReverseZ: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(left: number, right: number, bottom: number, top: number, near: number, far?: number, dst?: T | undefined) => T;
    getAxis: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, axis: number, dst?: T | undefined) => Float32Array<ArrayBufferLike> | T;
    getScaling: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    getTranslation: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    identity: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    inverse: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    invert: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    lookAt: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    mul: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    multiply: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    multiplyScalar: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    negate: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    ortho: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T | undefined) => T;
    perspective: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar: number, dst?: T | undefined) => T;
    perspectiveReverseZ: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar?: number, dst?: T | undefined) => T;
    rotate: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateX: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotation: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotationX: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationY: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationZ: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    scale: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    scaling: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    set: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, dst?: T | undefined) => T;
    setAxis: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, v: Vec3Arg, axis: number, dst: T) => T;
    setTranslation: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(a: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    translate: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    translation: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    transpose: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    uniformScale: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    uniformScaling: <T extends Mat4Arg = Float32Array<ArrayBufferLike>>(s: number, dst?: T | undefined) => T;
}, 
/**
 * Quaternion functions that default to returning `Float32Array`
 * @namespace
 */
quat: {
    create: (x?: number, y?: number, z?: number, w?: number) => Float32Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number, z?: number, w?: number) => Float32Array<ArrayBufferLike>;
    set: <T extends QuatArg = Float32Array<ArrayBufferLike>>(x: number, y: number, z: number, w: number, dst?: T | undefined) => T;
    fromAxisAngle: <T extends QuatArg = Float32Array<ArrayBufferLike>>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    toAxisAngle: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => {
        angle: number;
        axis: T;
    };
    angle: (a: QuatArg, b: QuatArg) => number;
    multiply: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    mul: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    rotateX: <T extends QuatArg = Float32Array<ArrayBufferLike>>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends QuatArg = Float32Array<ArrayBufferLike>>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends QuatArg = Float32Array<ArrayBufferLike>>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    slerp: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, t: number, dst?: T | undefined) => T;
    inverse: <T extends QuatArg = Float32Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    conjugate: <T extends QuatArg = Float32Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    fromMat: <T extends QuatArg = Float32Array<ArrayBufferLike>>(m: Mat3Arg | Mat4Arg, dst?: T | undefined) => T;
    fromEuler: <T extends QuatArg = Float32Array<ArrayBufferLike>>(xAngleInRadians: number, yAngleInRadians: number, zAngleInRadians: number, order: RotationOrder, dst?: T | undefined) => T;
    copy: <T extends QuatArg = Float32Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    clone: <T extends QuatArg = Float32Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    add: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    subtract: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    sub: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    mulScalar: <T extends QuatArg = Float32Array<ArrayBufferLike>>(v: QuatArg, k: number, dst?: T | undefined) => T;
    scale: <T extends QuatArg = Float32Array<ArrayBufferLike>>(v: QuatArg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends QuatArg = Float32Array<ArrayBufferLike>>(v: QuatArg, k: number, dst?: T | undefined) => T;
    dot: (a: QuatArg, b: QuatArg) => number;
    lerp: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, t: number, dst?: T | undefined) => T;
    length: (v: QuatArg) => number;
    len: (v: QuatArg) => number;
    lengthSq: (v: QuatArg) => number;
    lenSq: (v: QuatArg) => number;
    normalize: <T extends QuatArg = Float32Array<ArrayBufferLike>>(v: QuatArg, dst?: T | undefined) => T;
    equalsApproximately: (a: QuatArg, b: QuatArg) => boolean;
    equals: (a: QuatArg, b: QuatArg) => boolean;
    identity: <T extends QuatArg = Float32Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    rotationTo: <T extends QuatArg = Float32Array<ArrayBufferLike>>(aUnit: Vec3Arg, bUnit: Vec3Arg, dst?: T | undefined) => T;
    sqlerp: <T extends QuatArg = Float32Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, c: QuatArg, d: QuatArg, t: number, dst?: T | undefined) => T;
}, 
/**
 * Vec2 functions that default to returning `Float32Array`
 * @namespace
 */
vec2: {
    create: (x?: number, y?: number) => Float32Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number) => Float32Array<ArrayBufferLike>;
    set: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(x: number, y: number, dst?: T | undefined) => T;
    ceil: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    floor: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    round: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, scale: number, dst?: T | undefined) => T;
    angle: (a: Vec2Arg, b: Vec2Arg) => number;
    subtract: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    sub: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec2Arg, b: Vec2Arg) => boolean;
    equals: (a: Vec2Arg, b: Vec2Arg) => boolean;
    lerp: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, t: Vec2Arg, dst?: T | undefined) => T;
    max: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    min: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    invert: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    cross: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    dot: (a: Vec2Arg, b: Vec2Arg) => number;
    length: (v: Vec2Arg) => number;
    len: (v: Vec2Arg) => number;
    lengthSq: (v: Vec2Arg) => number;
    lenSq: (v: Vec2Arg) => number;
    distance: (a: Vec2Arg, b: Vec2Arg) => number;
    dist: (a: Vec2Arg, b: Vec2Arg) => number;
    distanceSq: (a: Vec2Arg, b: Vec2Arg) => number;
    distSq: (a: Vec2Arg, b: Vec2Arg) => number;
    normalize: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    negate: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    copy: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    clone: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    mul: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    divide: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    div: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    random: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(scale?: number, dst?: T | undefined) => T;
    zero: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat3: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(v: Vec2Arg, m: Mat3Arg, dst?: T | undefined) => T;
    rotate: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, rad: number, dst?: T | undefined) => T;
    setLength: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec2Arg = Float32Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
}, 
/**
 * Vec3 functions that default to returning `Float32Array`
 * @namespace
 */
vec3: {
    create: (x?: number, y?: number, z?: number) => Float32Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number, z?: number) => Float32Array<ArrayBufferLike>;
    set: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(x: number, y: number, z: number, dst?: T | undefined) => T;
    ceil: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    floor: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    round: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, scale: number, dst?: T | undefined) => T;
    angle: (a: Vec3Arg, b: Vec3Arg) => number;
    subtract: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    sub: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec3Arg, b: Vec3Arg) => boolean;
    equals: (a: Vec3Arg, b: Vec3Arg) => boolean;
    lerp: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, t: Vec3Arg, dst?: T | undefined) => T;
    max: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    min: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    invert: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    cross: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    dot: (a: Vec3Arg, b: Vec3Arg) => number;
    length: (v: Vec3Arg) => number;
    len: (v: Vec3Arg) => number;
    lengthSq: (v: Vec3Arg) => number;
    lenSq: (v: Vec3Arg) => number;
    distance: (a: Vec3Arg, b: Vec3Arg) => number;
    dist: (a: Vec3Arg, b: Vec3Arg) => number;
    distanceSq: (a: Vec3Arg, b: Vec3Arg) => number;
    distSq: (a: Vec3Arg, b: Vec3Arg) => number;
    normalize: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    negate: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    copy: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    clone: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    mul: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    divide: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    div: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    random: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(scale?: number, dst?: T | undefined) => T;
    zero: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat4Upper3x3: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat3: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, m: Mat3Arg, dst?: T | undefined) => T;
    transformQuat: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(v: Vec3Arg, q: QuatArg, dst?: T | undefined) => T;
    getTranslation: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    getAxis: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, axis: number, dst?: T | undefined) => T;
    getScaling: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    rotateX: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    rotateY: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    rotateZ: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    setLength: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec3Arg = Float32Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
}, 
/**
 * Vec3 functions that default to returning `Float32Array`
 * @namespace
 */
vec4: {
    create: (x?: number, y?: number, z?: number, w?: number) => Float32Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number, z?: number, w?: number) => Float32Array<ArrayBufferLike>;
    set: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(x: number, y: number, z: number, w: number, dst?: T | undefined) => T;
    ceil: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    floor: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    round: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, scale: number, dst?: T | undefined) => T;
    subtract: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    sub: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec4Arg, b: Vec4Arg) => boolean;
    equals: (a: Vec4Arg, b: Vec4Arg) => boolean;
    lerp: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, t: Vec4Arg, dst?: T | undefined) => T;
    max: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    min: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    invert: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    dot: (a: Vec4Arg, b: Vec4Arg) => number;
    length: (v: Vec4Arg) => number;
    len: (v: Vec4Arg) => number;
    lengthSq: (v: Vec4Arg) => number;
    lenSq: (v: Vec4Arg) => number;
    distance: (a: Vec4Arg, b: Vec4Arg) => number;
    dist: (a: Vec4Arg, b: Vec4Arg) => number;
    distanceSq: (a: Vec4Arg, b: Vec4Arg) => number;
    distSq: (a: Vec4Arg, b: Vec4Arg) => number;
    normalize: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    negate: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    copy: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    clone: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    mul: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    divide: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    div: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    zero: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(v: Vec4Arg, m: Mat4Arg, dst?: T | undefined) => T;
    setLength: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec4Arg = Float32Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
};
export declare const mat3d: {
    add: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    clone: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    copy: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    create: (v0?: number, v1?: number, v2?: number, v3?: number, v4?: number, v5?: number, v6?: number, v7?: number, v8?: number) => Float64Array<ArrayBufferLike>;
    determinant: (m: Mat3Arg) => number;
    equals: (a: Mat3Arg, b: Mat3Arg) => boolean;
    equalsApproximately: (a: Mat3Arg, b: Mat3Arg) => boolean;
    fromMat4: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m4: Mat4Arg, dst?: T | undefined) => T;
    fromQuat: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    get3DScaling: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => Float64Array<ArrayBufferLike> | T;
    getAxis: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, axis: number, dst?: T | undefined) => T;
    getScaling: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => Float64Array<ArrayBufferLike> | T;
    getTranslation: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    identity: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    inverse: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    invert: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    mul: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    multiply: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    multiplyScalar: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    negate: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    rotate: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateX: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotation: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationX: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationY: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationZ: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    scale: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    scale3D: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec3Arg, dst?: T | undefined) => T;
    scaling: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    scaling3D: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    set: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, dst?: T | undefined) => T;
    setAxis: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec2Arg, axis: number, dst?: T | undefined) => T;
    setTranslation: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(a: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    translate: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    translation: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    transpose: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    uniformScale: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    uniformScale3D: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    uniformScaling: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(s: number, dst?: T | undefined) => T;
    uniformScaling3D: <T extends Mat3Arg = Float64Array<ArrayBufferLike>>(s: number, dst?: T | undefined) => T;
}, mat4d: {
    add: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    aim: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(position: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    axisRotate: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    axisRotation: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    cameraAim: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    clone: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    copy: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    create: (v0?: number, v1?: number, v2?: number, v3?: number, v4?: number, v5?: number, v6?: number, v7?: number, v8?: number, v9?: number, v10?: number, v11?: number, v12?: number, v13?: number, v14?: number, v15?: number) => Float64Array<ArrayBufferLike>;
    determinant: (m: Mat4Arg) => number;
    equals: (a: Mat4Arg, b: Mat4Arg) => boolean;
    equalsApproximately: (a: Mat4Arg, b: Mat4Arg) => boolean;
    fromMat3: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m3: Mat3Arg, dst?: T | undefined) => T;
    fromQuat: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    frustum: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T | undefined) => T;
    frustumReverseZ: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(left: number, right: number, bottom: number, top: number, near: number, far?: number, dst?: T | undefined) => T;
    getAxis: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, axis: number, dst?: T | undefined) => Float64Array<ArrayBufferLike> | T;
    getScaling: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    getTranslation: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    identity: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    inverse: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    invert: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    lookAt: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    mul: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    multiply: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    multiplyScalar: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    negate: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    ortho: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T | undefined) => T;
    perspective: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar: number, dst?: T | undefined) => T;
    perspectiveReverseZ: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar?: number, dst?: T | undefined) => T;
    rotate: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateX: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotation: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotationX: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationY: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    rotationZ: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(angleInRadians: number, dst?: T | undefined) => T;
    scale: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    scaling: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    set: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, dst?: T | undefined) => T;
    setAxis: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, v: Vec3Arg, axis: number, dst: T) => T;
    setTranslation: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(a: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    translate: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    translation: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    transpose: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    uniformScale: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    uniformScaling: <T extends Mat4Arg = Float64Array<ArrayBufferLike>>(s: number, dst?: T | undefined) => T;
}, quatd: {
    create: (x?: number, y?: number, z?: number, w?: number) => Float64Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number, z?: number, w?: number) => Float64Array<ArrayBufferLike>;
    set: <T extends QuatArg = Float64Array<ArrayBufferLike>>(x: number, y: number, z: number, w: number, dst?: T | undefined) => T;
    fromAxisAngle: <T extends QuatArg = Float64Array<ArrayBufferLike>>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    toAxisAngle: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => {
        angle: number;
        axis: T;
    };
    angle: (a: QuatArg, b: QuatArg) => number;
    multiply: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    mul: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    rotateX: <T extends QuatArg = Float64Array<ArrayBufferLike>>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends QuatArg = Float64Array<ArrayBufferLike>>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends QuatArg = Float64Array<ArrayBufferLike>>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    slerp: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, t: number, dst?: T | undefined) => T;
    inverse: <T extends QuatArg = Float64Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    conjugate: <T extends QuatArg = Float64Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    fromMat: <T extends QuatArg = Float64Array<ArrayBufferLike>>(m: Mat3Arg | Mat4Arg, dst?: T | undefined) => T;
    fromEuler: <T extends QuatArg = Float64Array<ArrayBufferLike>>(xAngleInRadians: number, yAngleInRadians: number, zAngleInRadians: number, order: RotationOrder, dst?: T | undefined) => T;
    copy: <T extends QuatArg = Float64Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    clone: <T extends QuatArg = Float64Array<ArrayBufferLike>>(q: QuatArg, dst?: T | undefined) => T;
    add: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    subtract: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    sub: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    mulScalar: <T extends QuatArg = Float64Array<ArrayBufferLike>>(v: QuatArg, k: number, dst?: T | undefined) => T;
    scale: <T extends QuatArg = Float64Array<ArrayBufferLike>>(v: QuatArg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends QuatArg = Float64Array<ArrayBufferLike>>(v: QuatArg, k: number, dst?: T | undefined) => T;
    dot: (a: QuatArg, b: QuatArg) => number;
    lerp: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, t: number, dst?: T | undefined) => T;
    length: (v: QuatArg) => number;
    len: (v: QuatArg) => number;
    lengthSq: (v: QuatArg) => number;
    lenSq: (v: QuatArg) => number;
    normalize: <T extends QuatArg = Float64Array<ArrayBufferLike>>(v: QuatArg, dst?: T | undefined) => T;
    equalsApproximately: (a: QuatArg, b: QuatArg) => boolean;
    equals: (a: QuatArg, b: QuatArg) => boolean;
    identity: <T extends QuatArg = Float64Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    rotationTo: <T extends QuatArg = Float64Array<ArrayBufferLike>>(aUnit: Vec3Arg, bUnit: Vec3Arg, dst?: T | undefined) => T;
    sqlerp: <T extends QuatArg = Float64Array<ArrayBufferLike>>(a: QuatArg, b: QuatArg, c: QuatArg, d: QuatArg, t: number, dst?: T | undefined) => T;
}, vec2d: {
    create: (x?: number, y?: number) => Float64Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number) => Float64Array<ArrayBufferLike>;
    set: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(x: number, y: number, dst?: T | undefined) => T;
    ceil: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    floor: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    round: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, scale: number, dst?: T | undefined) => T;
    angle: (a: Vec2Arg, b: Vec2Arg) => number;
    subtract: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    sub: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec2Arg, b: Vec2Arg) => boolean;
    equals: (a: Vec2Arg, b: Vec2Arg) => boolean;
    lerp: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, t: Vec2Arg, dst?: T | undefined) => T;
    max: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    min: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    invert: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    cross: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    dot: (a: Vec2Arg, b: Vec2Arg) => number;
    length: (v: Vec2Arg) => number;
    len: (v: Vec2Arg) => number;
    lengthSq: (v: Vec2Arg) => number;
    lenSq: (v: Vec2Arg) => number;
    distance: (a: Vec2Arg, b: Vec2Arg) => number;
    dist: (a: Vec2Arg, b: Vec2Arg) => number;
    distanceSq: (a: Vec2Arg, b: Vec2Arg) => number;
    distSq: (a: Vec2Arg, b: Vec2Arg) => number;
    normalize: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    negate: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    copy: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    clone: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    mul: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    divide: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    div: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    random: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(scale?: number, dst?: T | undefined) => T;
    zero: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat3: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(v: Vec2Arg, m: Mat3Arg, dst?: T | undefined) => T;
    rotate: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, rad: number, dst?: T | undefined) => T;
    setLength: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec2Arg = Float64Array<ArrayBufferLike>>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
}, vec3d: {
    create: (x?: number, y?: number, z?: number) => Float64Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number, z?: number) => Float64Array<ArrayBufferLike>;
    set: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(x: number, y: number, z: number, dst?: T | undefined) => T;
    ceil: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    floor: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    round: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, scale: number, dst?: T | undefined) => T;
    angle: (a: Vec3Arg, b: Vec3Arg) => number;
    subtract: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    sub: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec3Arg, b: Vec3Arg) => boolean;
    equals: (a: Vec3Arg, b: Vec3Arg) => boolean;
    lerp: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, t: Vec3Arg, dst?: T | undefined) => T;
    max: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    min: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    invert: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    cross: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    dot: (a: Vec3Arg, b: Vec3Arg) => number;
    length: (v: Vec3Arg) => number;
    len: (v: Vec3Arg) => number;
    lengthSq: (v: Vec3Arg) => number;
    lenSq: (v: Vec3Arg) => number;
    distance: (a: Vec3Arg, b: Vec3Arg) => number;
    dist: (a: Vec3Arg, b: Vec3Arg) => number;
    distanceSq: (a: Vec3Arg, b: Vec3Arg) => number;
    distSq: (a: Vec3Arg, b: Vec3Arg) => number;
    normalize: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    negate: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    copy: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    clone: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    mul: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    divide: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    div: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    random: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(scale?: number, dst?: T | undefined) => T;
    zero: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat4Upper3x3: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat3: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, m: Mat3Arg, dst?: T | undefined) => T;
    transformQuat: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(v: Vec3Arg, q: QuatArg, dst?: T | undefined) => T;
    getTranslation: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(m: Mat3Arg, dst?: T | undefined) => T;
    getAxis: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, axis: number, dst?: T | undefined) => T;
    getScaling: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(m: Mat4Arg, dst?: T | undefined) => T;
    rotateX: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    rotateY: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    rotateZ: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    setLength: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec3Arg = Float64Array<ArrayBufferLike>>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
}, vec4d: {
    create: (x?: number, y?: number, z?: number, w?: number) => Float64Array<ArrayBufferLike>;
    fromValues: (x?: number, y?: number, z?: number, w?: number) => Float64Array<ArrayBufferLike>;
    set: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(x: number, y: number, z: number, w: number, dst?: T | undefined) => T;
    ceil: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    floor: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    round: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, scale: number, dst?: T | undefined) => T;
    subtract: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    sub: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec4Arg, b: Vec4Arg) => boolean;
    equals: (a: Vec4Arg, b: Vec4Arg) => boolean;
    lerp: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, t: Vec4Arg, dst?: T | undefined) => T;
    max: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    min: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    invert: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    dot: (a: Vec4Arg, b: Vec4Arg) => number;
    length: (v: Vec4Arg) => number;
    len: (v: Vec4Arg) => number;
    lengthSq: (v: Vec4Arg) => number;
    lenSq: (v: Vec4Arg) => number;
    distance: (a: Vec4Arg, b: Vec4Arg) => number;
    dist: (a: Vec4Arg, b: Vec4Arg) => number;
    distanceSq: (a: Vec4Arg, b: Vec4Arg) => number;
    distSq: (a: Vec4Arg, b: Vec4Arg) => number;
    normalize: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    negate: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    copy: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    clone: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    mul: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    divide: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    div: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    zero: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(v: Vec4Arg, m: Mat4Arg, dst?: T | undefined) => T;
    setLength: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec4Arg = Float64Array<ArrayBufferLike>>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
};
export declare const mat3n: {
    add: <T extends Mat3Arg = number[]>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    clone: <T extends Mat3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    copy: <T extends Mat3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    create: (v0?: number, v1?: number, v2?: number, v3?: number, v4?: number, v5?: number, v6?: number, v7?: number, v8?: number) => number[];
    determinant: (m: Mat3Arg) => number;
    equals: (a: Mat3Arg, b: Mat3Arg) => boolean;
    equalsApproximately: (a: Mat3Arg, b: Mat3Arg) => boolean;
    fromMat4: <T extends Mat3Arg = number[]>(m4: Mat4Arg, dst?: T | undefined) => T;
    fromQuat: <T extends Mat3Arg = number[]>(q: QuatArg, dst?: T | undefined) => T;
    get3DScaling: <T extends Vec3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => number[] | T;
    getAxis: <T extends Vec2Arg = number[]>(m: Mat3Arg, axis: number, dst?: T | undefined) => T;
    getScaling: <T extends Vec2Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => number[] | T;
    getTranslation: <T extends Vec2Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    identity: <T extends Mat3Arg = number[]>(dst?: T | undefined) => T;
    inverse: <T extends Mat3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    invert: <T extends Mat3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    mul: <T extends Mat3Arg = number[]>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Mat3Arg = number[]>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    multiply: <T extends Mat3Arg = number[]>(a: Mat3Arg, b: Mat3Arg, dst?: T | undefined) => T;
    multiplyScalar: <T extends Mat3Arg = number[]>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    negate: <T extends Mat3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    rotate: <T extends Mat3Arg = number[]>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateX: <T extends Mat3Arg = number[]>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends Mat3Arg = number[]>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends Mat3Arg = number[]>(m: Mat3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotation: <T extends Mat3Arg = number[]>(angleInRadians: number, dst?: T | undefined) => T;
    rotationX: <T extends Mat3Arg = number[]>(angleInRadians: number, dst?: T | undefined) => T;
    rotationY: <T extends Mat3Arg = number[]>(angleInRadians: number, dst?: T | undefined) => T;
    rotationZ: <T extends Mat3Arg = number[]>(angleInRadians: number, dst?: T | undefined) => T;
    scale: <T extends Mat3Arg = number[]>(m: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    scale3D: <T extends Mat3Arg = number[]>(m: Mat3Arg, v: Vec3Arg, dst?: T | undefined) => T;
    scaling: <T extends Mat3Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    scaling3D: <T extends Mat3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    set: <T extends Mat3Arg = number[]>(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, dst?: T | undefined) => T;
    setAxis: <T extends Mat3Arg = number[]>(m: Mat3Arg, v: Vec2Arg, axis: number, dst?: T | undefined) => T;
    setTranslation: <T extends Mat3Arg = number[]>(a: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    translate: <T extends Mat3Arg = number[]>(m: Mat3Arg, v: Vec2Arg, dst?: T | undefined) => T;
    translation: <T extends Mat3Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    transpose: <T extends Mat3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    uniformScale: <T extends Mat3Arg = number[]>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    uniformScale3D: <T extends Mat3Arg = number[]>(m: Mat3Arg, s: number, dst?: T | undefined) => T;
    uniformScaling: <T extends Mat3Arg = number[]>(s: number, dst?: T | undefined) => T;
    uniformScaling3D: <T extends Mat3Arg = number[]>(s: number, dst?: T | undefined) => T;
}, mat4n: {
    add: <T extends Mat4Arg = number[]>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    aim: <T extends Mat4Arg = number[]>(position: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    axisRotate: <T extends Mat4Arg = number[]>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    axisRotation: <T extends Mat4Arg = number[]>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    cameraAim: <T extends Mat4Arg = number[]>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    clone: <T extends Mat4Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    copy: <T extends Mat4Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    create: (v0?: number, v1?: number, v2?: number, v3?: number, v4?: number, v5?: number, v6?: number, v7?: number, v8?: number, v9?: number, v10?: number, v11?: number, v12?: number, v13?: number, v14?: number, v15?: number) => number[];
    determinant: (m: Mat4Arg) => number;
    equals: (a: Mat4Arg, b: Mat4Arg) => boolean;
    equalsApproximately: (a: Mat4Arg, b: Mat4Arg) => boolean;
    fromMat3: <T extends Mat4Arg = number[]>(m3: Mat3Arg, dst?: T | undefined) => T;
    fromQuat: <T extends Mat4Arg = number[]>(q: QuatArg, dst?: T | undefined) => T;
    frustum: <T extends Mat4Arg = number[]>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T | undefined) => T;
    frustumReverseZ: <T extends Mat4Arg = number[]>(left: number, right: number, bottom: number, top: number, near: number, far?: number, dst?: T | undefined) => T;
    getAxis: <T extends Vec3Arg = number[]>(m: Mat4Arg, axis: number, dst?: T | undefined) => number[] | T;
    getScaling: <T extends Vec3Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    getTranslation: <T extends Vec3Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    identity: <T extends Mat4Arg = number[]>(dst?: T | undefined) => T;
    inverse: <T extends Mat4Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    invert: <T extends Mat4Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    lookAt: <T extends Mat4Arg = number[]>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T | undefined) => T;
    mul: <T extends Mat4Arg = number[]>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Mat4Arg = number[]>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    multiply: <T extends Mat4Arg = number[]>(a: Mat4Arg, b: Mat4Arg, dst?: T | undefined) => T;
    multiplyScalar: <T extends Mat4Arg = number[]>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    negate: <T extends Mat4Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    ortho: <T extends Mat4Arg = number[]>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T | undefined) => T;
    perspective: <T extends Mat4Arg = number[]>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar: number, dst?: T | undefined) => T;
    perspectiveReverseZ: <T extends Mat4Arg = number[]>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar?: number, dst?: T | undefined) => T;
    rotate: <T extends Mat4Arg = number[]>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateX: <T extends Mat4Arg = number[]>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends Mat4Arg = number[]>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends Mat4Arg = number[]>(m: Mat4Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotation: <T extends Mat4Arg = number[]>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    rotationX: <T extends Mat4Arg = number[]>(angleInRadians: number, dst?: T | undefined) => T;
    rotationY: <T extends Mat4Arg = number[]>(angleInRadians: number, dst?: T | undefined) => T;
    rotationZ: <T extends Mat4Arg = number[]>(angleInRadians: number, dst?: T | undefined) => T;
    scale: <T extends Mat4Arg = number[]>(m: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    scaling: <T extends Mat4Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    set: <T extends Mat4Arg = number[]>(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, dst?: T | undefined) => T;
    setAxis: <T extends Mat4Arg = number[]>(m: Mat4Arg, v: Vec3Arg, axis: number, dst: T) => T;
    setTranslation: <T extends Mat4Arg = number[]>(a: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    translate: <T extends Mat4Arg = number[]>(m: Mat4Arg, v: Vec3Arg, dst?: T | undefined) => T;
    translation: <T extends Mat4Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    transpose: <T extends Mat4Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    uniformScale: <T extends Mat4Arg = number[]>(m: Mat4Arg, s: number, dst?: T | undefined) => T;
    uniformScaling: <T extends Mat4Arg = number[]>(s: number, dst?: T | undefined) => T;
}, quatn: {
    create: (x?: number, y?: number, z?: number, w?: number) => number[];
    fromValues: (x?: number, y?: number, z?: number, w?: number) => number[];
    set: <T extends QuatArg = number[]>(x: number, y: number, z: number, w: number, dst?: T | undefined) => T;
    fromAxisAngle: <T extends QuatArg = number[]>(axis: Vec3Arg, angleInRadians: number, dst?: T | undefined) => T;
    toAxisAngle: <T extends Vec3Arg = number[]>(q: QuatArg, dst?: T | undefined) => {
        angle: number;
        axis: T;
    };
    angle: (a: QuatArg, b: QuatArg) => number;
    multiply: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    mul: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    rotateX: <T extends QuatArg = number[]>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    rotateY: <T extends QuatArg = number[]>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    rotateZ: <T extends QuatArg = number[]>(q: QuatArg, angleInRadians: number, dst?: T | undefined) => T;
    slerp: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, t: number, dst?: T | undefined) => T;
    inverse: <T extends QuatArg = number[]>(q: QuatArg, dst?: T | undefined) => T;
    conjugate: <T extends QuatArg = number[]>(q: QuatArg, dst?: T | undefined) => T;
    fromMat: <T extends QuatArg = number[]>(m: Mat3Arg | Mat4Arg, dst?: T | undefined) => T;
    fromEuler: <T extends QuatArg = number[]>(xAngleInRadians: number, yAngleInRadians: number, zAngleInRadians: number, order: RotationOrder, dst?: T | undefined) => T;
    copy: <T extends QuatArg = number[]>(q: QuatArg, dst?: T | undefined) => T;
    clone: <T extends QuatArg = number[]>(q: QuatArg, dst?: T | undefined) => T;
    add: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    subtract: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    sub: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, dst?: T | undefined) => T;
    mulScalar: <T extends QuatArg = number[]>(v: QuatArg, k: number, dst?: T | undefined) => T;
    scale: <T extends QuatArg = number[]>(v: QuatArg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends QuatArg = number[]>(v: QuatArg, k: number, dst?: T | undefined) => T;
    dot: (a: QuatArg, b: QuatArg) => number;
    lerp: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, t: number, dst?: T | undefined) => T;
    length: (v: QuatArg) => number;
    len: (v: QuatArg) => number;
    lengthSq: (v: QuatArg) => number;
    lenSq: (v: QuatArg) => number;
    normalize: <T extends QuatArg = number[]>(v: QuatArg, dst?: T | undefined) => T;
    equalsApproximately: (a: QuatArg, b: QuatArg) => boolean;
    equals: (a: QuatArg, b: QuatArg) => boolean;
    identity: <T extends QuatArg = number[]>(dst?: T | undefined) => T;
    rotationTo: <T extends QuatArg = number[]>(aUnit: Vec3Arg, bUnit: Vec3Arg, dst?: T | undefined) => T;
    sqlerp: <T extends QuatArg = number[]>(a: QuatArg, b: QuatArg, c: QuatArg, d: QuatArg, t: number, dst?: T | undefined) => T;
}, vec2n: {
    create: (x?: number, y?: number) => number[];
    fromValues: (x?: number, y?: number) => number[];
    set: <T extends Vec2Arg = number[]>(x: number, y: number, dst?: T | undefined) => T;
    ceil: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    floor: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    round: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec2Arg = number[]>(v: Vec2Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, scale: number, dst?: T | undefined) => T;
    angle: (a: Vec2Arg, b: Vec2Arg) => number;
    subtract: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    sub: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec2Arg, b: Vec2Arg) => boolean;
    equals: (a: Vec2Arg, b: Vec2Arg) => boolean;
    lerp: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, t: Vec2Arg, dst?: T | undefined) => T;
    max: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    min: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec2Arg = number[]>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec2Arg = number[]>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec2Arg = number[]>(v: Vec2Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    invert: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    cross: <T extends Vec3Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    dot: (a: Vec2Arg, b: Vec2Arg) => number;
    length: (v: Vec2Arg) => number;
    len: (v: Vec2Arg) => number;
    lengthSq: (v: Vec2Arg) => number;
    lenSq: (v: Vec2Arg) => number;
    distance: (a: Vec2Arg, b: Vec2Arg) => number;
    dist: (a: Vec2Arg, b: Vec2Arg) => number;
    distanceSq: (a: Vec2Arg, b: Vec2Arg) => number;
    distSq: (a: Vec2Arg, b: Vec2Arg) => number;
    normalize: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    negate: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    copy: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    clone: <T extends Vec2Arg = number[]>(v: Vec2Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    mul: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    divide: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    div: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
    random: <T extends Vec2Arg = number[]>(scale?: number, dst?: T | undefined) => T;
    zero: <T extends Vec2Arg = number[]>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec2Arg = number[]>(v: Vec2Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat3: <T extends Vec2Arg = number[]>(v: Vec2Arg, m: Mat3Arg, dst?: T | undefined) => T;
    rotate: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, rad: number, dst?: T | undefined) => T;
    setLength: <T extends Vec2Arg = number[]>(a: Vec2Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec2Arg = number[]>(a: Vec2Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec2Arg = number[]>(a: Vec2Arg, b: Vec2Arg, dst?: T | undefined) => T;
}, vec3n: {
    create: (x?: number, y?: number, z?: number) => number[];
    fromValues: (x?: number, y?: number, z?: number) => number[];
    set: <T extends Vec3Arg = number[]>(x: number, y: number, z: number, dst?: T | undefined) => T;
    ceil: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    floor: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    round: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec3Arg = number[]>(v: Vec3Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, scale: number, dst?: T | undefined) => T;
    angle: (a: Vec3Arg, b: Vec3Arg) => number;
    subtract: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    sub: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec3Arg, b: Vec3Arg) => boolean;
    equals: (a: Vec3Arg, b: Vec3Arg) => boolean;
    lerp: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, t: Vec3Arg, dst?: T | undefined) => T;
    max: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    min: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec3Arg = number[]>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec3Arg = number[]>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec3Arg = number[]>(v: Vec3Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    invert: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    cross: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    dot: (a: Vec3Arg, b: Vec3Arg) => number;
    length: (v: Vec3Arg) => number;
    len: (v: Vec3Arg) => number;
    lengthSq: (v: Vec3Arg) => number;
    lenSq: (v: Vec3Arg) => number;
    distance: (a: Vec3Arg, b: Vec3Arg) => number;
    dist: (a: Vec3Arg, b: Vec3Arg) => number;
    distanceSq: (a: Vec3Arg, b: Vec3Arg) => number;
    distSq: (a: Vec3Arg, b: Vec3Arg) => number;
    normalize: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    negate: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    copy: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    clone: <T extends Vec3Arg = number[]>(v: Vec3Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    mul: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    divide: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    div: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
    random: <T extends Vec3Arg = number[]>(scale?: number, dst?: T | undefined) => T;
    zero: <T extends Vec3Arg = number[]>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec3Arg = number[]>(v: Vec3Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat4Upper3x3: <T extends Vec3Arg = number[]>(v: Vec3Arg, m: Mat4Arg, dst?: T | undefined) => T;
    transformMat3: <T extends Vec3Arg = number[]>(v: Vec3Arg, m: Mat3Arg, dst?: T | undefined) => T;
    transformQuat: <T extends Vec3Arg = number[]>(v: Vec3Arg, q: QuatArg, dst?: T | undefined) => T;
    getTranslation: <T extends Vec3Arg = number[]>(m: Mat3Arg, dst?: T | undefined) => T;
    getAxis: <T extends Vec3Arg = number[]>(m: Mat4Arg, axis: number, dst?: T | undefined) => T;
    getScaling: <T extends Vec3Arg = number[]>(m: Mat4Arg, dst?: T | undefined) => T;
    rotateX: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    rotateY: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    rotateZ: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T | undefined) => T;
    setLength: <T extends Vec3Arg = number[]>(a: Vec3Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec3Arg = number[]>(a: Vec3Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec3Arg = number[]>(a: Vec3Arg, b: Vec3Arg, dst?: T | undefined) => T;
}, vec4n: {
    create: (x?: number, y?: number, z?: number, w?: number) => number[];
    fromValues: (x?: number, y?: number, z?: number, w?: number) => number[];
    set: <T extends Vec4Arg = number[]>(x: number, y: number, z: number, w: number, dst?: T | undefined) => T;
    ceil: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    floor: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    round: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    clamp: <T extends Vec4Arg = number[]>(v: Vec4Arg, min?: number, max?: number, dst?: T | undefined) => T;
    add: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    addScaled: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, scale: number, dst?: T | undefined) => T;
    subtract: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    sub: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    equalsApproximately: (a: Vec4Arg, b: Vec4Arg) => boolean;
    equals: (a: Vec4Arg, b: Vec4Arg) => boolean;
    lerp: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, t: number, dst?: T | undefined) => T;
    lerpV: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, t: Vec4Arg, dst?: T | undefined) => T;
    max: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    min: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    mulScalar: <T extends Vec4Arg = number[]>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    scale: <T extends Vec4Arg = number[]>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    divScalar: <T extends Vec4Arg = number[]>(v: Vec4Arg, k: number, dst?: T | undefined) => T;
    inverse: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    invert: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    dot: (a: Vec4Arg, b: Vec4Arg) => number;
    length: (v: Vec4Arg) => number;
    len: (v: Vec4Arg) => number;
    lengthSq: (v: Vec4Arg) => number;
    lenSq: (v: Vec4Arg) => number;
    distance: (a: Vec4Arg, b: Vec4Arg) => number;
    dist: (a: Vec4Arg, b: Vec4Arg) => number;
    distanceSq: (a: Vec4Arg, b: Vec4Arg) => number;
    distSq: (a: Vec4Arg, b: Vec4Arg) => number;
    normalize: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    negate: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    copy: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    clone: <T extends Vec4Arg = number[]>(v: Vec4Arg, dst?: T | undefined) => T;
    multiply: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    mul: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    divide: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    div: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
    zero: <T extends Vec4Arg = number[]>(dst?: T | undefined) => T;
    transformMat4: <T extends Vec4Arg = number[]>(v: Vec4Arg, m: Mat4Arg, dst?: T | undefined) => T;
    setLength: <T extends Vec4Arg = number[]>(a: Vec4Arg, len: number, dst?: T | undefined) => T;
    truncate: <T extends Vec4Arg = number[]>(a: Vec4Arg, maxLen: number, dst?: T | undefined) => T;
    midpoint: <T extends Vec4Arg = number[]>(a: Vec4Arg, b: Vec4Arg, dst?: T | undefined) => T;
};
