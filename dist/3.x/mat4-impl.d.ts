import { Mat4Arg, Mat4Type } from './mat4';
import { Mat3Arg } from './mat3';
import { QuatArg } from './quat';
import { Vec3Arg } from './vec3';
import { BaseArgType } from './types';
export { Mat4Arg, Mat4Type };
type Mat4Ctor<T extends Mat4Arg = Float32Array> = new (n: number) => T;
/**
 * Generates a typed API for Mat4
 * */
declare function getAPIImpl<MatType extends Mat4Arg = Float32Array>(Ctor: Mat4Ctor<MatType>): {
    add: <T extends Mat4Arg = MatType>(a: Mat4Arg, b: Mat4Arg, dst?: T) => T;
    aim: <T extends Mat4Arg = MatType>(position: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T) => T;
    axisRotate: <T extends Mat4Arg = MatType>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T) => T;
    axisRotation: <T extends Mat4Arg = MatType>(axis: Vec3Arg, angleInRadians: number, dst?: T) => T;
    cameraAim: <T extends Mat4Arg = MatType>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T) => T;
    clone: <T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    copy: <T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    create: (v0?: number, v1?: number, v2?: number, v3?: number, v4?: number, v5?: number, v6?: number, v7?: number, v8?: number, v9?: number, v10?: number, v11?: number, v12?: number, v13?: number, v14?: number, v15?: number) => MatType;
    determinant: (m: Mat4Arg) => number;
    equals: (a: Mat4Arg, b: Mat4Arg) => boolean;
    equalsApproximately: (a: Mat4Arg, b: Mat4Arg) => boolean;
    fromMat3: <T extends Mat4Arg = MatType>(m3: Mat3Arg, dst?: T) => T;
    fromQuat: <T extends Mat4Arg = MatType>(q: QuatArg, dst?: T) => T;
    frustum: <T extends Mat4Arg = MatType>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T) => T;
    frustumReverseZ: <T extends Mat4Arg = MatType>(left: number, right: number, bottom: number, top: number, near: number, far?: number, dst?: T) => T;
    getAxis: <T extends Vec3Arg = MatType>(m: Mat4Arg, axis: number, dst?: T) => MatType | T;
    getScaling: <T extends Vec3Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    getTranslation: <T extends Vec3Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    identity: <T extends Mat4Arg = MatType>(dst?: T) => T;
    inverse: <T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    invert: <T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    lookAt: <T extends Mat4Arg = MatType>(eye: Vec3Arg, target: Vec3Arg, up: Vec3Arg, dst?: T) => T;
    mul: <T extends Mat4Arg = MatType>(a: Mat4Arg, b: Mat4Arg, dst?: T) => T;
    mulScalar: <T extends Mat4Arg = MatType>(m: Mat4Arg, s: number, dst?: T) => T;
    multiply: <T extends Mat4Arg = MatType>(a: Mat4Arg, b: Mat4Arg, dst?: T) => T;
    multiplyScalar: <T extends Mat4Arg = MatType>(m: Mat4Arg, s: number, dst?: T) => T;
    negate: <T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    ortho: <T extends Mat4Arg = MatType>(left: number, right: number, bottom: number, top: number, near: number, far: number, dst?: T) => T;
    perspective: <T extends Mat4Arg = MatType>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar: number, dst?: T) => T;
    perspectiveReverseZ: <T extends Mat4Arg = MatType>(fieldOfViewYInRadians: number, aspect: number, zNear: number, zFar?: number, dst?: T) => T;
    rotate: <T extends Mat4Arg = MatType>(m: Mat4Arg, axis: Vec3Arg, angleInRadians: number, dst?: T) => T;
    rotateX: <T extends Mat4Arg = MatType>(m: Mat4Arg, angleInRadians: number, dst?: T) => T;
    rotateY: <T extends Mat4Arg = MatType>(m: Mat4Arg, angleInRadians: number, dst?: T) => T;
    rotateZ: <T extends Mat4Arg = MatType>(m: Mat4Arg, angleInRadians: number, dst?: T) => T;
    rotation: <T extends Mat4Arg = MatType>(axis: Vec3Arg, angleInRadians: number, dst?: T) => T;
    rotationX: <T extends Mat4Arg = MatType>(angleInRadians: number, dst?: T) => T;
    rotationY: <T extends Mat4Arg = MatType>(angleInRadians: number, dst?: T) => T;
    rotationZ: <T extends Mat4Arg = MatType>(angleInRadians: number, dst?: T) => T;
    scale: <T extends Mat4Arg = MatType>(m: Mat4Arg, v: Vec3Arg, dst?: T) => T;
    scaling: <T extends Mat4Arg = MatType>(v: Vec3Arg, dst?: T) => T;
    set: <T extends Mat4Arg = MatType>(v0: number, v1: number, v2: number, v3: number, v4: number, v5: number, v6: number, v7: number, v8: number, v9: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number, dst?: T) => T;
    setAxis: <T extends Mat4Arg = MatType>(m: Mat4Arg, v: Vec3Arg, axis: number, dst: T) => T;
    setTranslation: <T extends Mat4Arg = MatType>(a: Mat4Arg, v: Vec3Arg, dst?: T) => T;
    translate: <T extends Mat4Arg = MatType>(m: Mat4Arg, v: Vec3Arg, dst?: T) => T;
    translation: <T extends Mat4Arg = MatType>(v: Vec3Arg, dst?: T) => T;
    transpose: <T extends Mat4Arg = MatType>(m: Mat4Arg, dst?: T) => T;
    uniformScale: <T extends Mat4Arg = MatType>(m: Mat4Arg, s: number, dst?: T) => T;
    uniformScaling: <T extends Mat4Arg = MatType>(s: number, dst?: T) => T;
};
type API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;
export declare function getAPI<T extends Mat4Arg = Float32Array>(Ctor: Mat4Ctor<T>): API<T>;
