import { Vec3Arg, Vec3Type } from './vec3';
import { Mat3Arg } from './mat3';
import { Mat4Arg } from './mat4';
import { QuatArg } from './quat';
import { BaseArgType } from './types';
export { Vec3Arg, Vec3Type };
type Vec3Ctor<T extends Vec3Arg = Float32Array> = new (n: number) => T;
/**
 * Generates am typed API for Vec3
 * */
declare function getAPIImpl<VecType extends Vec3Arg = Float32Array>(Ctor: Vec3Ctor<VecType>): {
    create: (x?: number, y?: number, z?: number) => VecType;
    fromValues: (x?: number, y?: number, z?: number) => VecType;
    set: <T extends Vec3Arg = VecType>(x: number, y: number, z: number, dst?: T) => T;
    ceil: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    floor: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    round: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    clamp: <T extends Vec3Arg = VecType>(v: Vec3Arg, min?: number, max?: number, dst?: T) => T;
    add: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    addScaled: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, scale: number, dst?: T) => T;
    angle: (a: Vec3Arg, b: Vec3Arg) => number;
    subtract: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    sub: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    equalsApproximately: (a: Vec3Arg, b: Vec3Arg) => boolean;
    equals: (a: Vec3Arg, b: Vec3Arg) => boolean;
    lerp: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, t: number, dst?: T) => T;
    lerpV: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, t: Vec3Arg, dst?: T) => T;
    max: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    min: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    mulScalar: <T extends Vec3Arg = VecType>(v: Vec3Arg, k: number, dst?: T) => T;
    scale: <T extends Vec3Arg = VecType>(v: Vec3Arg, k: number, dst?: T) => T;
    divScalar: <T extends Vec3Arg = VecType>(v: Vec3Arg, k: number, dst?: T) => T;
    inverse: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    invert: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    cross: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    dot: (a: Vec3Arg, b: Vec3Arg) => number;
    length: (v: Vec3Arg) => number;
    len: (v: Vec3Arg) => number;
    lengthSq: (v: Vec3Arg) => number;
    lenSq: (v: Vec3Arg) => number;
    distance: (a: Vec3Arg, b: Vec3Arg) => number;
    dist: (a: Vec3Arg, b: Vec3Arg) => number;
    distanceSq: (a: Vec3Arg, b: Vec3Arg) => number;
    distSq: (a: Vec3Arg, b: Vec3Arg) => number;
    normalize: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    negate: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    copy: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    clone: <T extends Vec3Arg = VecType>(v: Vec3Arg, dst?: T) => T;
    multiply: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    mul: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    divide: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    div: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
    random: <T extends Vec3Arg = VecType>(scale?: number, dst?: T) => T;
    zero: <T extends Vec3Arg = VecType>(dst?: T) => T;
    transformMat4: <T extends Vec3Arg = VecType>(v: Vec3Arg, m: Mat4Arg, dst?: T) => T;
    transformMat4Upper3x3: <T extends Vec3Arg = VecType>(v: Vec3Arg, m: Mat4Arg, dst?: T) => T;
    transformMat3: <T extends Vec3Arg = VecType>(v: Vec3Arg, m: Mat3Arg, dst?: T) => T;
    transformQuat: <T extends Vec3Arg = VecType>(v: Vec3Arg, q: QuatArg, dst?: T) => T;
    getTranslation: <T extends Vec3Arg = VecType>(m: Mat3Arg, dst?: T) => T;
    getAxis: <T extends Vec3Arg = VecType>(m: Mat4Arg, axis: number, dst?: T) => T;
    getScaling: <T extends Vec3Arg = VecType>(m: Mat4Arg, dst?: T) => T;
    rotateX: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T) => T;
    rotateY: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T) => T;
    rotateZ: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, rad: number, dst?: T) => T;
    setLength: <T extends Vec3Arg = VecType>(a: Vec3Arg, len: number, dst?: T) => T;
    truncate: <T extends Vec3Arg = VecType>(a: Vec3Arg, maxLen: number, dst?: T) => T;
    midpoint: <T extends Vec3Arg = VecType>(a: Vec3Arg, b: Vec3Arg, dst?: T) => T;
};
type API<T extends BaseArgType = Float32Array> = ReturnType<typeof getAPIImpl<T>>;
export declare function getAPI<T extends Mat4Arg = Float32Array>(Ctor: Vec3Ctor<T>): API<T>;
